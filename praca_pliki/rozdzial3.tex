\chapter{Implementacja modelu programowego}
Pierwszym zadaniem było stworzenie modeli programowych algorytmów MeanShift oraz Hog+SVM, bez warstwy nadzorującej/sterującej dronem. Wybrano środowisko MATLAB ze względu na jego powszechne zastosowanie w branży naukowej/inżynierskiej, co skutkuje olbrzymią bazą bibliotek i materiałów pomocniczych. W tym przypadku MATLAB ułatwia pracę na obrazach lub sekwencjach wideo poprzez: wczytywanie materiału, wyświetlanie, dostęp do poszczególnych klatek oraz zapewnia wiele wbudowanych funkcji, m.in. do konwersji określonych przestrzeni barw oraz obliczania maszyny wektorów nośnych.

\section{Model MeanShift}

Skrypt rozpoczyna działanie od wyznaczenia jądra obszaru o wymiarach $100 \times 100$ oraz jego gradientów. Po tym następuje właściwa część algorytmu, która pracuje na wczytanym materiale wideo, przekonwertowanym do przestrzeni HSV. Obszarem śledzonym jest kwadrat $100\times 100$, który dla pierwszej klatki obrazu jest zlokalizowany w miejscu startowym ramki $1280\times 720$ pikseli. Dla tego fragmentu obliczany jest histogram barw. Wczytując kolejne klatki, algorytm oblicza histogram kandydatów ostatecznie zestawiając go z oryginalnym i wyznaczając przesunięcie w pionie i poziomie. Dla każdej z klatek operacja ta jest przeprowadzana 10 razy, poprawiając precyzję ostatecznego przesunięcia. Przed rozpoczęciem przetwarzania kolejnej klatki, następuje aktualizacja pozycji obszaru. Po wykonaniu algorytmu dla zdefiniowanej liczbie klatek, skrypt wyświetla film w oryginalnych barwach RGB z dorysowaną czerwoną ramką otaczającą śledzony obszar, co pozwala wizualnie sprawdzić poprawność działania całego kodu. Niestety, czas wykonania tej symulacji jest nieporównywalnie dłuższy od rzeczywistego trwania sekwencji i, przykładowo, na notebooku wyposażonym w procesor klasy i7 materiał o długości XXX jest przetwarzany w czasie ok. 

\section{Model HoG+SVM}

Głównym zadaniem modelu programowego jest próba znalezienia osoby w przeskalowanym obrazie, bazując na obszarze wokół wprowadzonych współrzędnych punktu środkowego.

Działanie skryptu rozpoczyna się od przeprowadzenia sekwencji uczenia klasyfikatora, która bazuje na dwóch tablicach: jedna agreguje wektory cech, a druga przechowuje skojarzone z nimi klasy (0 lub 1). Wykorzystywana baza obrazów wyposażona jest w pliki z ich listami (osobno dla pozytywnych i negatywnych przykładów), co umożliwia proste wczytywanie kolejnych próbek. Oczekuje się tu rozmiaru $128\times 64$ pikseli, jednak niektóre (zwłaszcza negatywne) obrazy są za duże - przeprowadza się tutaj wycięcie fragmentu o podanym wyżej rozmiarze ze środka każdej próbki. Kolejnymi etapami dla takiego obszaru są kolejno: konwersja do odcieni szarości oraz obliczenie wektora cech. Ten proces przeprowadzono zgodnie z informacjami zawartymi w \ref{sec:HOG&SVM}; za normę blokową obrano L2 (\ref{eq:HOG_norm3}), natomiast rozmiar komórki to $4\times 4$ piksele. Po przetworzeniu każdego obrazu dopisuje się wektor cech oraz klasę do odpowiednich tablic.
\newline
Gotowe zestawy danych stanowią parametry dla wbudowanej w MATLABa funkcji \textit{svmtrain}, która zwraca strukturę \textit{svm\char`_struct} z parametrami wykorzystywanymi potem przez klasyfikator.

Opisany powyżej proces ma powtarzalne wyniki, jest jednorazowy, lecz także dość czasochłonny - dlatego nie ma potrzeby przeprowadzać go niepotrzebnie (sprawdzana jest obecność zmiennej \textit{svm\char`_struct}).

Właściwa część skryptu rozpoczyna się od wczytania obrazu wejściowego. O jego odpowiednim przeskalowaniu decyduje parametr ustawiany przed rozpoczęciem działania. W ten sposób zdefiniowane są również współrzędne środka obszaru detekcji. Kolejnym krokiem jest obliczenie $5\times 9$ wektorów cech na fragmencie $144 \times 96$ - widoczna różnica w podejściu względem procesu uczenia wynika z planu znalezienia jak najlepszego wyniku detekcji w danym obszarze. Idąc za przykładem wbudowanej w MATLAB funkcji \textit{svmclassify}, następuje klasyfikacja każdego obliczonego wektora cech. Końcowym etapem jest wyświetlenie przeskalowanego obrazu w kolorze, z naniesionym konturem o wymiarach $128\times 64$ otaczającym obszar najlepszej detekcji.